knitr::opts_chunk$set(echo = TRUE)
MC.simple = function(x,R=1e4){
u = runif(R,0,x)
INTEG = x*mean(exp(u))
}
MC.ant = function(x,R=1e4){
u = runif(R/2,0,x)
v = 1-u
u = c(u,v)
INTEG = x*mean(exp(u))
}
set.seed(123)
m = 1000
MC1 <- MC2 <- numeric(m)
for(i in 1:1000){
MC1[i] = MC.simple(1)
MC2[i] = MC.ant(1)
}
v.simple = var(MC1)
v.ant = var(MC2)
v.simple = var(MC1)
v.ant = var(MC2)
(v.simple-v.ant)/v.simple
v.simple = var(MC1)
v.simple
v.ant
MC.simple = function(x,R=1e4){
u = runif(R,0,x)
INTEG = x*mean(exp(-u)/(1+u^2))
}
MC.ant = function(x,R=1e4){
u = runif(R/2,0,x)
v = 1-u
u = c(u,v)
INTEG = x*mean(exp(-u)/(1+u^2))
}
set.seed(123)
m = 1000
MC1 <- MC2 <- numeric(m)
for(i in 1:1000){
MC1[i] = MC.simple(1)
MC2[i] = MC.ant(1)
}
v.simple = var(MC1)
v.ant = var(MC2)
(v.simple-v.ant)/v.simple
MC1
MC2
set.seed(123)
# Define the function to calculate the volume of a d-dimensional hypersphere
hypersphere_volume <- function(d, r) {
return((2^d * r^d * pi^(d/2)) / gamma(d/2 + 1))
}
# Define the function to calculate pi using Monte Carlo simulation
monte_carlo_pi <- function(d, digits) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x <- matrix(runif(n*d, -r, r), ncol = d)
in_circle <- rowSums(x^2) <= r^2
pi_estimate <- 2^d * mean(in_circle) * hypersphere_volume(d, r)
if (round(pi_estimate, digits) == round(pi, digits)) {
break
}
n <- n + 1
}
return(n)
}
# Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
dimensions <- 2:10
sample_sizes <- apply(dimensions, 1, monte_carlo_pi, digits = 5)
?apply
gamma(5)
gamma(1.5)
0.5*sqrt(pi)
314159%%1
314159%%10
314159%/%10
314159.123%/%1
?sqrt
?rowSums
3^(1/3)
?apply
<- 2:10
# Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
dimensions <- 2:10
dimensions
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (f*2^d*gamma(d/2+1))^(2/d)
if (pi_estimate*1e5%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
# Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
dimensions <- 2:10
sample_sizes <- apply(dimensions, 2, MC_pi)
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (f*2^d*gamma(d/2+1))^(2/d)
if (pi_estimate*1e5%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimension[i])
}
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (f*2^d*gamma(d/2+1))^(2/d)
if (pi_estimate*1e5%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if (pi_estimate*1e5%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if (pi_estimate*1e5%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e2)%/%1 == 314) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,n))
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e2)%/%1 == 314) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
# # Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
# dimensions <- 2:10
# sample_sizes <- apply(dimensions, 1, MC_pi)
#
# # Print the results in a table
# cat("| **Dimension** | **Sample Size** |\n")
# cat("|---------------|----------------|\n")
# for (i in seq_along(dimensions)) {
#   cat(sprintf("| %d             | %d              |\n", dimensions[i], sample_sizes[i]))
# }
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e2)%/%1 == 314) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
# # Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
# dimensions <- 2:10
# sample_sizes <- apply(dimensions, 1, MC_pi)
#
# # Print the results in a table
# cat("| **Dimension** | **Sample Size** |\n")
# cat("|---------------|----------------|\n")
# for (i in seq_along(dimensions)) {
#   cat(sprintf("| %d             | %d              |\n", dimensions[i], sample_sizes[i]))
# }
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e4)%/%1 == 31415) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
# # Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
# dimensions <- 2:10
# sample_sizes <- apply(dimensions, 1, MC_pi)
#
# # Print the results in a table
# cat("| **Dimension** | **Sample Size** |\n")
# cat("|---------------|----------------|\n")
# for (i in seq_along(dimensions)) {
#   cat(sprintf("| %d             | %d              |\n", dimensions[i], sample_sizes[i]))
# }
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e5)%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:3
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
# # Calculate the sample size needed to approximate pi to its 5th digit for each dimension d using apply function
# dimensions <- 2:10
# sample_sizes <- apply(dimensions, 1, MC_pi)
#
# # Print the results in a table
# cat("| **Dimension** | **Sample Size** |\n")
# cat("|---------------|----------------|\n")
# for (i in seq_along(dimensions)) {
#   cat(sprintf("| %d             | %d              |\n", dimensions[i], sample_sizes[i]))
# }
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d, digits=5) {
r <- 0.5
n <- 1
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e5)%/%1 == 314159) {
break
}
n <- n + 1
}
return(n)
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d) {
r <- 0.5
n <- 1
x = matrix(runif(1*d, -r, r),ncol=d)
pi_estimate <- 0
while (TRUE) {
x = matrix(runif(n*d, -r, r), ncol = d)
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e5)%/%1 == 314159) {
break
}
n <- n + 1
x = rbind(x,matrix(runif(1*d, -r, r),ncol=d))
}
return(n)
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
print(rbind(dimensions,ns))
table(rbind(dimensions,ns))
as.data.frame(rbind(dimensions,ns))
print(rbind(dimensions,ns))
print(rbind(dimensions,ns))
a = matrix(c(1,2,3,4),ncol=2)
a
dim(a)
dim(a)[1]
a = matrix(c(1,2,3,4),ncol=4)
dim(a)
set.seed(123)
# Define the function to calculate pi using Monte Carlo simulation
MC_pi <- function(d) {
r <- 0.5
x = matrix(runif(d, -r, r),ncol=d)
pi_estimate <- 0
while (TRUE) {
in_sphere = rowSums(x^2) <= r^2
fraction = mean(in_sphere)
pi_estimate = (fraction*2^d*gamma(d/2+1))^(2/d)
if ((pi_estimate*1e5)%/%1 == 314159) {
break
}
x = rbind(x,matrix(runif(d, -r, r),ncol=d))
}
return(dim(x)[1])
}
dimensions = 2:10
ns = numeric(length(dimensions))
for(i in 1:length(dimensions)){
ns[i] = MC_pi(dimensions[i])
}
print(rbind(dimensions,ns))
#            [,1] [,2]  [,3]  [,4] [,5]  [,6]  [,7]  [,8]  [,9]
# dimensions    2    3     4     5    6     7     8     9    10
# ns         5205 4746 10800 14189 5152 27660 13624 12573 14054
